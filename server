from fastapi import FastAPI, UploadFile, File, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
import nest_asyncio

# Dummy placeholders for model and predict functions (replace with actual logic)
def parl(contents, model): return {"result": "parkinson prediction"}
def tumor(contents, model): return {"result": "tumor prediction"}
def alzheimer(contents, model): return {"result": "alzheimer prediction"}
xry, tmkc, alz = "dummy_model", "dummy_model", "dummy_model"

# Setup
app = FastAPI()
users_db = {}
SECRET_KEY = "your-secret-key"  # Use a strong key in production
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_headers=["*"],
    allow_methods=["*"]
)

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str):
    return pwd_context.hash(password)

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

# JWT handling
def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def decode_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return username
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/login/")

# Dependency for protected routes
async def get_current_user(token: str = Depends(oauth2_scheme)):
    return decode_token(token)

# Pydantic models
class UserSignup(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

# Routes
@app.post("/signup/")
def signup(user: UserSignup):
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="Username already exists")
    hashed_password = hash_password(user.password)
    users_db[user.username] = hashed_password
    return {"message": "Signup successful"}

@app.post("/login/", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    username = form_data.username
    password = form_data.password
    user_password_hash = users_db.get(username)
    if not user_password_hash or not verify_password(password, user_password_hash):
        raise HTTPException(status_code=400, detail="Invalid credentials")
    access_token = create_access_token(data={"sub": username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/secure-data/")
def secure_data(current_user: str = Depends(get_current_user)):
    return {"message": f"Hello, {current_user}. You have access to this protected data."}

# Secure image endpoints using JWT
@app.post("/parlkins")
async def analyze_x_ray(
    file: UploadFile = File(...),
    current_user: str = Depends(get_current_user)
):
    contents = await file.read()
    prediction = parl(contents, xry)
    return prediction

@app.post("/tumor")
async def analyze_tumor(
    file: UploadFile = File(...),
    current_user: str = Depends(get_current_user)
):
    contents = await file.read()
    prediction = tumor(contents, tmkc)
    return prediction

@app.post("/alzheimer")
async def analyze_alzheimer(
    file: UploadFile = File(...),
    current_user: str = Depends(get_current_user)
):
    contents = await file.read()
    prediction = alzheimer(contents, alz)
    return prediction

nest_asyncio.apply()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)
